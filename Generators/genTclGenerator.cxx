/*=========================================================================

  Program:   Insight Segmentation & Registration Toolkit
  Module:    genTclGenerator.cxx
  Language:  C++
  Date:      $Date$
  Version:   $Revision$

Copyright (c) 2001 Insight Consortium
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * The name of the Insight Consortium, nor the names of any consortium members,
   nor of any contributors, may be used to endorse or promote products derived
   from this software without specific prior written permission.

  * Modified source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=========================================================================*/
#include "genTclGenerator.h"

#include <iostream>
#include <fstream>

namespace gen
{

typedef configuration::CableConfiguration CableConfiguration;

/**
 * Construct an instance of this generator and return it.
 */
GeneratorBase* TclGenerator::GetInstance(const configuration::Package* in_package,
                                         const source::Namespace* in_globalNamespace)
{
  return new TclGenerator(in_package, in_globalNamespace);
}


/**
 * Generate Tcl wrappers for all packages specified in the configuration.
 */
void
TclGenerator
::Generate()
{
  this->GeneratePackage(m_Package);
}


/**
 * Generate a package of Tcl wrappers according to the given
 * configuration.
 */
void TclGenerator::GeneratePackage(const configuration::Package* package)
{
  // Make sure the output directory exists.
  if(!GeneratorBase::MakeDirectory("Tcl"))
    {
    std::cerr << "Error making Tcl directory." << std::endl;
    return;
    }
  
  // Setup the output file names.
  String wrapperFile = "Tcl/"+package->GetName()+"_tcl.cxx";
  
  // Open the output files.
  std::ofstream wrapperStream(wrapperFile.c_str());
  if(!wrapperStream) { return; }
  
  wrapperStream <<
    "/**\n"
    " * Automatically generated by CABLE.  Do not edit!\n"
    " */\n"
    "\n"
    "// Include standard wrapper header.\n"
    "#include \"wrapCalls.h\"\n"
    "\n"
    "// Include headers needed for wrapped types.\n"
    "#include \"Cxx/" << package->GetName().c_str() << "_cxx.h\"\n";
  
  // Be sure to include needed headers.
  this->GenerateIncludes(wrapperStream, package->GetHeaders());

  // Add all types that will be used by the wrappers to our CvTypeGenerator.
  this->FindCvTypes(package->GetStartingNamespace());

  // Write out the block of CvType specializations for all needed types.
  wrapperStream <<
    "\n"
    "namespace _wrap_\n"
    "{\n"
    "// Define a CvType specialization for each type used in these wrappers.\n";
  m_CvTypeGenerator.GenerateClasses(wrapperStream);
  wrapperStream <<
    "\n";
  m_CvTypeGenerator.GenerateDataDeclarations(wrapperStream);
  wrapperStream <<
    "} // namespace _wrap_\n"
    "\n";
  
  // Begin the recursive generation at the package's starting namespace.
  this->GenerateNamespace(wrapperStream, package->GetStartingNamespace());

  // Write out the block of CvType initializations.
  wrapperStream <<
    "namespace _wrap_\n"
    "{\n"
    "\n"
    "void InitializeTypeRepresentations()\n"
    "{\n";
  m_CvTypeGenerator.GenerateInitalizations(wrapperStream);  
  wrapperStream <<
    "}\n"
    "\n"
    "void " << package->GetName().c_str() << "_Wrapper_Initialize(Tcl_Interp* interp)\n"
    "{\n"
    "  Initialize();\n";
  
  for(WrapperList::const_iterator w = m_WrapperList.begin();
      w != m_WrapperList.end(); ++w)
    {
    wrapperStream <<
      "  Wrapper< " << w->c_str() << " >::GetForInterpreter(interp);\n";
    }

  String tclName = package->GetName();
  String::iterator c = tclName.begin();
  if(c != tclName.end())
    {
    for(++c; c != tclName.end(); ++c)
      {
      char ch = *c;
      if((ch >= 'A') && (ch <= 'Z'))
        {
        *c = (ch+('a'-'A'));
        }
      }
    }
  
  wrapperStream <<
    "}\n"
    "\n"
    "} // namespace _wrap_\n"
    "\n"
    "extern \"C\" { WRAPPER_EXPORT int " << tclName.c_str() << "tcl_Init(Tcl_Interp* interp); }\n"
    "extern \"C\" { _wrap_EXPORT int Wrap_Init(Tcl_Interp* interp); }\n"
    "\n"
    "int " << tclName.c_str() << "tcl_Init(Tcl_Interp* interp)\n"
    "{\n"
    "  // Make sure the wrapper facility has been initialized for this interpreter.\n"
    "  int result = Wrap_Init(interp);\n"
    "  if(result != TCL_OK)\n"
    "    {\n"
    "    return result;\n"
    "    }\n"
    "  \n"
    "  // Initialized the types in this package.\n"
    "  _wrap_::" << package->GetName().c_str() << "_Wrapper_Initialize(interp);\n"
    "  \n"
    "  return TCL_OK;\n"
    "}\n";
  
  // Output file is complete.
  wrapperStream.close();
}


/**
 * Generate the set of #include lines for the set of headers given.
 */
void TclGenerator::GenerateIncludes(std::ostream& wrapperStream,
                                    const configuration::Headers* headers)
{
  // Make sure we have headers to write out.
  if(!headers)
    {
    return;
    }
  
  // Include headers with the "all" purpose.
  for(configuration::Headers::FilesIterator header = headers->BeginFiles();
      header != headers->EndFiles(); ++header)
    {
    if(header->purpose == "" || header->purpose == "all")
      {
      wrapperStream << "#include \"" << header->name.c_str() << "\"\n";
      }
    }
}


/**
 * Generate Tcl wrappers for all WrapperSets defined in the given namespace
 * and its nested namespaces.
 */
void TclGenerator::GenerateNamespace(std::ostream& wrapperStream,
                                     const configuration::PackageNamespace* ns)
{
  // Look through all the wrapper entries in this namespace.  These may
  // include both WrapperSets and nested PackageNamespaces.
  for(configuration::PackageNamespace::WrapperIterator wIter =
        ns->BeginWrappers();
      wIter != ns->EndWrappers(); ++wIter)
    {
    const configuration::Named* wrapper = *wIter;
    if(wrapper->IsPackageNamespace())
      {
      // Recursively look for WrapperSets in the nested namespace.
      this->GenerateNamespace(wrapperStream,
                              dynamic_cast<const configuration::PackageNamespace*>(wrapper));
      }
    else if(wrapper->IsWrapperSet())
      {
      // Generate wrappers for this WrapperSet.
      this->GenerateWrapperSet(wrapperStream,
                               dynamic_cast<const configuration::WrapperSet*>(wrapper),
                               ns);
      }
    }
}


void
TclGenerator
::GenerateWrapperSet(std::ostream& wrapperStream,
                     const configuration::WrapperSet* wrapperSet,
                     const configuration::PackageNamespace* ns)
{
  String qualifedName = ns->GetQualifiedName()+"::"+wrapperSet->GetName();
  source::Class* wStruct = m_GlobalNamespace->LookupClass(qualifedName);
  if(!wStruct)
    {
    wrapperStream << "// Couldn't find wrapper struct " << qualifedName.c_str() << std::endl;
    return;
    }
  for(configuration::WrapperSet::ConstIterator wrapper = wrapperSet->Begin();
      wrapper != wrapperSet->End(); ++wrapper)
    {
    source::Class* c = wStruct->LookupClass(wrapper->first);
    if(c)
      {
      this->GenerateClassWrapper(wrapperStream, c);
      }
    else
      {
      wrapperStream << "// Couldn't find type " << wrapper->first.c_str() << std::endl;
      }
    }
}

void
TclGenerator
::GenerateClassWrapper(std::ostream& wrapperStream,
                       const source::Class* c)
{
  String cName = c->GetQualifiedName();
  
  m_WrapperList.push_back(cName);
  
  // Make a list of the methods in this class that will be wrapped.
  Methods methods;
  for(source::MethodsIterator methodItr = c->GetMethods().begin();
      methodItr != c->GetMethods().end(); ++methodItr)
    {
    source::Method* method = *methodItr;
    if(method->GetAccess() == source::Public)
      {
      if(method->IsMethod()
         || method->IsConstructor()
         || method->IsOperatorMethod())
        {
        methods.push_back(method);
        }
      }
    }
  
  // Write out code to define the Wrapper template specialization
  // for this wrapped class.
  this->WriteWrapperClassDefinition(wrapperStream, c, methods);
  
  wrapperStream <<
    "namespace _wrap_\n"
    "{\n"
    "\n";

  for(unsigned int m = 0 ; m < methods.size() ; ++m)
    {
    if(methods[m]->IsMethod())
      {
      wrapperStream <<
        "void\n"
        "Wrapper< " << cName.c_str() << " >\n"
        "::Method_" << m << "_" << methods[m]->GetName().c_str() << "(const Argument& implicit, const Arguments& arguments) const\n"
        "{\n";
      
      this->WriteImplicitArgument(wrapperStream, c, methods[m]);
      this->WriteReturnBegin(wrapperStream, methods[m]);
      
      wrapperStream <<
        "  instance." << methods[m]->GetName() << "(";
      
      this->WriteArgumentList(wrapperStream, methods[m]->GetArguments());

      this->WriteReturnEnd(wrapperStream, methods[m]);
      
      wrapperStream << ");\n"
        "}\n"
        "\n";
      }
    else if(methods[m]->IsOperatorMethod())
      {
      wrapperStream <<
        "void\n"
        "Wrapper< " << cName.c_str() << " >\n"
        "::Operator_" << m << "_" << this->GetOperatorName(methods[m]->GetName()).c_str() << "(const Argument& implicit, const Arguments& arguments) const\n"
        "{\n";
      
      this->WriteImplicitArgument(wrapperStream, c, methods[m]);
      this->WriteReturnBegin(wrapperStream, methods[m]);
      
      wrapperStream <<
        "  instance.operator" << methods[m]->GetName() << "(";
      
      this->WriteArgumentList(wrapperStream, methods[m]->GetArguments());

      this->WriteReturnEnd(wrapperStream, methods[m]);
      
      wrapperStream << ");\n"
        "}\n"
        "\n";
      }
    else if(methods[m]->IsConstructor())
      {
        wrapperStream <<
          "void*\n"
          "Wrapper< " << cName.c_str() << " >\n"
          "::Constructor_" << m << "(const Arguments& arguments) const\n"
          "{\n"
          "  return new " << cName.c_str() << "(";
        
        this->WriteArgumentList(wrapperStream, methods[m]->GetArguments());
        
        wrapperStream << ");\n"
          "}\n"
          "\n";
      }
    }
  
  wrapperStream <<
    "\n"
    "void\n"
    "Wrapper< " << cName.c_str() << " >\n"
    "::RegisterMethodWrappers()\n"
    "{\n";

  for(unsigned int m = 0 ; m < methods.size() ; ++m)
    {
    if(!methods[m]->GetArguments().empty())
      {
      wrapperStream <<
        "  {\n"
        "  Method::ParameterTypes parameterTypes;\n";
      for(source::ArgumentsIterator a = methods[m]->GetArguments().begin();
          a != methods[m]->GetArguments().end(); ++a)
        {
        const source::Type* t = (*a)->GetType();
        wrapperStream <<
          "  parameterTypes.push_back(CvType< " << this->GetCxxType(t).GetName() << " >::type.GetType());\n";
        }
      }

    wrapperStream <<
      "  this->AddFunction(\n";
    
    if(methods[m]->IsMethod())
      {
      String returnTypeName = "void";
      if(methods[m]->GetReturns() && methods[m]->GetReturns()->GetType())
        {
        returnTypeName = this->GetCxxType(methods[m]->GetReturns()->GetType()).GetName();
        }
      wrapperStream <<
        "    new Method(this, &Wrapper::Method_" << m << "_" << methods[m]->GetName() << ",\n"
        "               \"" << methods[m]->GetName() << "\", " << (methods[m]->IsConst() ? "true":"false") << ",\n"
        "               CvType< " << returnTypeName.c_str() << " >::type";
      }
    else if(methods[m]->IsOperatorMethod())
      {
      String returnTypeName = "void";
      if(methods[m]->GetReturns() && methods[m]->GetReturns()->GetType())
        {
        returnTypeName = this->GetCxxType(methods[m]->GetReturns()->GetType()).GetName();
        }
      wrapperStream <<
        "    new Method(this, &Wrapper::Operator_" << m << "_" << this->GetOperatorName(methods[m]->GetName()).c_str() << ",\n"
        "               \"" << methods[m]->GetName() << "\", " << (methods[m]->IsConst() ? "true":"false") << ",\n"
        "               CvType< " << returnTypeName.c_str() << " >::type";
      }
    else if(methods[m]->IsConstructor())
      {
      wrapperStream <<
        "    new Constructor(this, &Wrapper::Constructor_" << m << ",\n"
        "                    \"" << cName << "\"";
      
      }
    
    if(methods[m]->GetArguments().empty())
      {
      wrapperStream << "));\n";
      }
    else
      {
      wrapperStream << ",\n"
        "      parameterTypes));\n"
        "  }\n";
      }
    }

  wrapperStream <<
    "}\n"
    "\n";

  wrapperStream <<
    "} // namespace _wrap_\n"
    "\n";
}

bool TclGenerator::ReturnsVoid(const source::Function* f) const
{      
  if(!f->GetReturns() || !f->GetReturns()->GetType())
    { return true; }
  else
    {
    const cxx::Type* rt = this->GetCxxType(f->GetReturns()->GetType()).GetType();
    if(rt->IsFundamentalType())
      {
      return cxx::FundamentalType::SafeDownCast(rt)->IsVoid();
      }
    }
  return false;
}

void TclGenerator::WriteWrapperClassDefinition(std::ostream& wrapperStream,
                                               const source::Class* c,
                                               const Methods& methods) const
{
  String cName = c->GetQualifiedName();
  wrapperStream <<
    "//--------------------------------------------------------------------\n"
    "// Class wrapper definition for\n"
    "//   " <<  cName.c_str() << "\n"
    "//--------------------------------------------------------------------\n"
    "\n"
    "// These macros will control creation of the Wrapper class.\n"
    "#define _wrap_WRAPPED_TYPE " << cName.c_str() << "\n"
    "#define _wrap_WRAPPED_TYPE_NAME \"" << cName.c_str() << "\"\n"
    "#define _wrap_METHOD_WRAPPER_PROTOTYPES \\\n";
  
  if(!methods.empty())
    {
    for(unsigned int m = 0 ; m < methods.size() ;)
      {
      if(methods[m]->IsMethod())
        {
        wrapperStream <<
          "  void Method_" << m << "_" << methods[m]->GetName().c_str() << "(const Argument&, const Arguments&) const";
        }
      if(methods[m]->IsOperatorMethod())
        {
        wrapperStream <<
          "  void Operator_" << m << "_" << this->GetOperatorName(methods[m]->GetName()).c_str() << "(const Argument&, const Arguments&) const";
        }
      else if(methods[m]->IsConstructor())
        {
        wrapperStream <<
          "  void* Constructor_" << m << "(const Arguments&) const";
        }
      if(++m != methods.size())
        {
        wrapperStream << "; \\";
        }
      wrapperStream << "\n";
      }
    }
  else
    {
    wrapperStream <<
      "  typedef int PlaceholderForNoMethodWrappers\n";
    }
  
  wrapperStream <<
    "\n"
    "// This include will produce a specialization of template class\n"
    "// Wrapper according to the macros we just defined.\n"
    "#include \"wrapWrapperInclude.h\"\n"
    "\n"
    "// We are done with these macros.\n"
    "#undef _wrap_METHOD_WRAPPER_PROTOTYPES\n"
    "#undef _wrap_WRAPPED_TYPE_NAME\n"
    "#undef _wrap_WRAPPED_TYPE\n"
    "\n";
}

void TclGenerator::WriteImplicitArgument(std::ostream& wrapperStream,
                                         const source::Class* c, const source::Method* m) const
{
  String implicit = c->GetQualifiedName();
  if(m->IsConst())
    {
    implicit = "const "+implicit;
    }
  wrapperStream <<
    "  " << implicit.c_str() << "& instance = ArgumentAsReferenceTo< " << implicit.c_str() << " >::Get(implicit, this);\n";
}

void TclGenerator::WriteReturnBegin(std::ostream& wrapperStream,
                                    const source::Function* f) const
{
  if(!this->ReturnsVoid(f))
    {
    const source::Type* t = f->GetReturns()->GetType();
    if(t->IsPointerType())
      {
      const source::PointerType* pt = dynamic_cast<const source::PointerType*>(t);
      t = pt->GetPointedToType();
      wrapperStream <<
        "  ReturnPointerTo< " << this->GetCxxType(t).GetName() << " >::From(\n";
      }
    else if(t->IsReferenceType())
      {
      const source::ReferenceType* rt = dynamic_cast<const source::ReferenceType*>(t);
      t = rt->GetReferencedType();
      wrapperStream <<
        "  ReturnReferenceTo< " << this->GetCxxType(t).GetName() << " >::From(\n";
      }
    else
      {
      wrapperStream <<
        "  Return< " << this->GetCxxType(t).GetName() << " >::From(\n";
      }
    }
}

void TclGenerator::WriteReturnEnd(std::ostream& wrapperStream,
                                  const source::Function* f) const
{      
  if(this->ReturnsVoid(f))
    {
    wrapperStream << ");\n"
      "  Return<void>::From(this";
    }
  else
    {
    wrapperStream << "), this";
    }
}

/**
 * Write the code to convert and pass a list of arguments to wrapped method
 * in its method wrapper's actual call to it.
 */
void TclGenerator::WriteArgumentList(std::ostream& wrapperStream,
                                     const source::ArgumentContainer& arguments) const
{
  unsigned int argCount = 0;
  source::ArgumentsIterator a = arguments.begin();
  if(a != arguments.end())
    {
    wrapperStream << "\n";
    this->WriteArgumentAs(wrapperStream,
                          this->GetCxxType((*a)->GetType()), argCount++);
    for(++a;a != arguments.end(); ++a)
      {
      wrapperStream << ",\n";
      this->WriteArgumentAs(wrapperStream,
                            this->GetCxxType((*a)->GetType()), argCount++);
      }
    }
}


/**
 * Write the ArgumentAs... call needed to access the given argument
 * index as the given type.  This may be one of
 *  ArgumentAs<T>                   for object T
 *  ArgumentAsReferenceTo<T>        for reference type T&
 *  GetArgumentAsReferenceTo_const  for reference type const T&
 *  ArgumentAsPointerTo<T>          for pointer type T*
 *  ArgumentAsPointerToFunction<T>  for type T, a pointer to function
 */
void TclGenerator::WriteArgumentAs(std::ostream& wrapperStream,
                                   const cxx::CvQualifiedType& cvType,
                                   unsigned int argIndex) const
{
  const cxx::Type* type = cvType.GetType();
  if(type->IsReferenceType())
    {
    cxx::CvQualifiedType rt = cxx::ReferenceType::SafeDownCast(type)->GetReferencedType();
    if(rt.IsConst() && !rt.IsVolatile()
       && !(rt.GetType()->IsClassType()
            && cxx::ClassType::SafeDownCast(rt.GetType())->IsAbstract()))
      {
      cxx::CvQualifiedType nrt = rt.GetType()->GetCvQualifiedType(false, false);
      wrapperStream <<
        "    GetArgumentAsReferenceTo_const< " << nrt.GetName() << " >(this)(arguments[" << argIndex << "])";
      }
    else
      {
      wrapperStream <<
        "    ArgumentAsReferenceTo< " << rt.GetName() << " >::Get(arguments[" << argIndex << "], this)";
      }
    }
  else if(type->IsPointerType())
    {
    cxx::CvQualifiedType pt = cxx::PointerType::SafeDownCast(type)->GetPointedToType();
    if(pt.GetType()->IsFunctionType())
      {
      wrapperStream <<
        "    ArgumentAsPointerToFunction< " << cvType.GetName() << " >::Get(arguments[" << argIndex << "], this)";
      }
    else
      {
      wrapperStream <<
        "    ArgumentAsPointerTo< " << pt.GetName() << " >::Get(arguments[" << argIndex << "], this)";
      }
    }
  else
    {
    wrapperStream <<
      "    ArgumentAs< " << cvType.GetName() << " >::Get(arguments[" << argIndex << "], this)";
    }
}


void TclGenerator::FindCvTypes(const configuration::PackageNamespace* ns)
{
  for(configuration::PackageNamespace::WrapperIterator wIter =
        ns->BeginWrappers();
      wIter != ns->EndWrappers(); ++wIter)
    {
    const configuration::Named* wrapper = *wIter;
    if(wrapper->IsPackageNamespace())
      {
      this->FindCvTypes(dynamic_cast<const configuration::PackageNamespace*>(wrapper));
      }
    else if(wrapper->IsWrapperSet())
      {
      this->FindCvTypes(dynamic_cast<const configuration::WrapperSet*>(wrapper), ns);
      }
    }
}

void
TclGenerator
::FindCvTypes(const configuration::WrapperSet* wrapperSet,
              const configuration::PackageNamespace* ns)
{
  String qualifedName = ns->GetQualifiedName()+"::"+wrapperSet->GetName();
  source::Class* wStruct = m_GlobalNamespace->LookupClass(qualifedName);
  if(!wStruct)
    {
    return;
    }
  for(configuration::WrapperSet::ConstIterator wrapper = wrapperSet->Begin();
      wrapper != wrapperSet->End(); ++wrapper)
    {
    source::Class* c = wStruct->LookupClass(wrapper->first);
    if(c)
      {
      this->FindCvTypes(c);
      }
    }
}

void TclGenerator::FindCvTypes(const source::Class* c)
{
  // Add the implict argument types for method calls.
  cxx::CvQualifiedType classCvType = c->GetCxxClassType(m_GlobalNamespace);
  cxx::CvQualifiedType constClassCvType = classCvType.GetMoreQualifiedType(true, false);  
  m_CvTypeGenerator.Add(source::CxxTypes::GetReferenceType(classCvType));
  m_CvTypeGenerator.Add(source::CxxTypes::GetReferenceType(constClassCvType));
  
  for(source::MethodsIterator methodItr = c->GetMethods().begin();
      methodItr != c->GetMethods().end(); ++methodItr)
    {
    source::Method* method = *methodItr;
    if(method->GetAccess() == source::Public)
      {
      if(method->IsMethod()
         || method->IsConstructor()
         || method->IsOperatorMethod())
        {
        this->FindCvTypes(method);
        }
      }
    }
}
  
void TclGenerator::FindCvTypes(const source::Method* method)
{
  if(method->GetReturns() && method->GetReturns()->GetType())
    {
    m_CvTypeGenerator.Add(this->GetCxxType(method->GetReturns()->GetType()));
    }
  for(source::ArgumentsIterator a = method->GetArguments().begin();
      a != method->GetArguments().end(); ++a)
    {
    m_CvTypeGenerator.Add(this->GetCxxType((*a)->GetType()));
    }
}

cxx::CvQualifiedType TclGenerator::GetCxxType(const source::Type* t) const
{
  return t->GetCxxType(m_GlobalNamespace);
}

} // namespace gen
